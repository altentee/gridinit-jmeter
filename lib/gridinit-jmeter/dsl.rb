module Gridinit

  module Jmeter

    class ExtendedDSL < DSL
      include Parser
      attr_accessor :root

      def initialize(params = {})
        @root = Nokogiri::XML(<<-EOF.strip_heredoc)
          <?xml version="1.0" encoding="UTF-8"?>
          <jmeterTestPlan version="1.2" properties="2.1">
          <hashTree>
          </hashTree>
          </jmeterTestPlan>
        EOF
        node = Gridinit::Jmeter::TestPlan.new(params)

        @current_node = @root.at_xpath("//jmeterTestPlan/hashTree")
        @current_node = attach_to_last(node)

        variables :name     => 'testguid',
                  :value    => '${__P(testguid,${__time(,)})}',
                  :comments => 'Gridinit testguid automatically generated by DSL'
      end

      ##
      # Config Elements

      def user_defined_variables(params, &block)
        params['Argument.name'] = params[:name]
        super
      end

      alias_method :variables, :user_defined_variables

      alias_method :defaults, :http_request_defaults      

      def http_cookie_manager(params={}, &block)
        params[:clearEachIteration] = true if params.keys.include? 'clear_each_iteration'
        super
      end

      alias_method :cookies, :http_cookie_manager

      def http_cache_manager(params={}, &block)
        params[:clearEachIteration] = true if params.keys.include? 'clear_each_iteration'
        super
      end

      alias_method :cache, :http_cache_manager

      def with_user_agent(device)
        http_header_manager name: 'User-Agent', 
                            value: Gridinit::Jmeter::UserAgent.new(device).string
      end

      def http_header_manager(params, &block)
        params['Header.name'] = params[:name]
        super
      end

      alias_method :header, :http_header_manager

      alias_method :auth, :http_authorization_manager

      def thread_group(*args, &block)
        params = args.shift || {}
        params = { count: params }.merge(args.shift || {}) if params.class == Fixnum
        params[:num_threads]        = params[:count] || 1
        params[:ramp_time]          = params[:rampup] || (params[:num_threads]/2.0).ceil
        params[:start_time]         = params[:start_time] || Time.now.to_i * 1000
        params[:end_time]           = params[:end_time] || Time.now.to_i * 1000
        params[:duration]         ||= 60
        params[:continue_forever] ||= false
        params[:loops]              = -1 if params[:continue_forever]
        node = Gridinit::Jmeter::ThreadGroup.new(params)
        attach_node(node, &block)
      end

      alias_method :threads, :thread_group

      ##
      # HTTP Samplers

      def get(*args, &block)
        params = args.shift || {}
        params = { url: params }.merge(args.shift || {}) if params.class == String
        params[:method] ||= 'GET'
        params[:name] ||= params[:url]
        parse_http_request(params)
        node = Gridinit::Jmeter::HttpRequest.new(params)
        attach_node(node, &block)
      end

      alias_method :visit, :get

      def post(*args, &block)
        params = args.shift || {}
        params = { url: params }.merge(args.shift || {}) if params.class == String
        params[:method] ||= 'POST'
        params[:name] ||= params[:url]
        parse_http_request(params)
        node = Gridinit::Jmeter::HttpRequest.new(params)
        attach_node(node, &block)
      end

      alias_method :submit, :post

      def delete(*args, &block)
        params = args.shift || {}
        params = { url: params }.merge(args.shift || {}) if params.class == String
        params[:method] ||= 'DELETE'
        params[:name] ||= params[:url]
        parse_http_request(params)
        node = Gridinit::Jmeter::HttpRequest.new(params)
        attach_node(node, &block)
      end

      def put(*args, &block)
        params = args.shift || {}
        params = { url: params }.merge(args.shift || {}) if params.class == String
        params[:method] ||= 'PUT'
        params[:name] ||= params[:url]
        parse_http_request(params)
        node = Gridinit::Jmeter::HttpRequest.new(params)
        attach_node(node, &block)
      end

      def with_xhr
        http_header_manager name: 'X-Requested-With', 
                            value: 'XMLHttpRequest'
      end

      ##
      # Other Samplers

      def soapxmlrpc_request(params, &block)
        params[:method] ||= 'POST'
        super
      end

      alias_method :soap, :soapxmlrpc_request

      alias_method :ldap, :ldap_request

      alias_method :ldap_ext, :ldap_extended_request

      alias_method :ldap_extended, :ldap_extended_request


      ##
      # Controllers

      def transaction_controller(*args, &block)
        params = args.shift || {}
        params = { name: params }.merge(args.shift || {}) if params.class == String
        params[:parent] ||= true
        params[:includeTimers] = params[:include_timers] || false
        node = Gridinit::Jmeter::TransactionController.new(params)
        attach_node(node, &block)
      end

      alias_method :transaction, :transaction_controller

      def exists(variable, &block)
        params ||= {}
        params[:condition] = "'${#{variable}}'.length > 0"
        node = Gridinit::Jmeter::IfController.new(params)
        attach_node(node, &block)
      end

      alias_method :If, :if_controller

      def loop_controller(params, &block)
        params[:loops] = params[:count] || 1
        super
      end

      alias_method :Loop, :loop_controller

      def throughput_controller(params, &block)
        params[:style] = 1 if params[:percent]
        params[:maxThroughput] = params[:total] || params[:percent] || 1

        node = Gridinit::Jmeter::ThroughputController.new(params)
        node.doc.xpath(".//FloatProperty/value").first.content = params[:maxThroughput].to_f
       
        attach_node(node, &block)
      end

      alias_method :Throughput, :throughput_controller

      alias_method :Switch, :switch_controller

      alias_method :While, :while_controller

      alias_method :Interleave, :random_controller

      alias_method :Random_order, :random_order_controller

      alias_method :Simple, :simple_controller

      alias_method :Once, :once_only_controller

      ##
      # Listeners

      alias_method :view_results, :view_results_tree

      alias_method :log, :simple_data_writer

      alias_method :response_graph, :response_time_graph

      ##
      # Other Elements

      alias_method :bsh_pre, :beanshell_preprocessor

      alias_method :bsh_post, :beanshell_postprocessor

      def extract(params, &block)
        node = if params[:regex]
          params[:refname] = params[:name]
          params[:regex] = params[:regex] #CGI.escapeHTML 
          params[:template] = params[:template] || "$1$"
          Gridinit::Jmeter::RegularExpressionExtractor.new(params)
        else
          params[:refname] = params[:name]
          params[:xpathQuery] = params[:xpath]
          Gridinit::Jmeter::XpathExtractor.new(params)
        end
        attach_node(node, &block)
      end

      alias_method :web_reg_save_param, :extract

      def random_timer(delay=0, range=0, &block)
        params={}
        params[:delay] = delay
        params[:range] = range
        node = Gridinit::Jmeter::GaussianRandomTimer.new(params)
        attach_node(node, &block)
      end

      alias_method :think_time, :random_timer

      def response_assertion(params={}, &block)
        params[:test_type] = parse_test_type(params)
        params[:match] = params.values.first
        node = Gridinit::Jmeter::ResponseAssertion.new(params)
        node.doc.xpath("//stringProp[@name='Assertion.scope']").remove if
          params[:scope] == 'main' || params['scope'] == 'main'
        attach_node(node, &block)
      end

      alias_method :assert, :response_assertion

      alias_method :web_reg_find, :response_assertion

      ##
      # JMeter Plugins

      def response_codes_per_second(name="jp@gc - Response Codes per Second", params={}, &block)
        node = Gridinit::Jmeter::GCResponseCodesPerSecond.new(name, params)
        attach_node(node, &block)
      end

      def response_times_distribution(name="jp@gc - Response Times Distribution", params={}, &block)
        node = Gridinit::Jmeter::GCResponseTimesDistribution.new(name, params)
        attach_node(node, &block)
      end

      def response_times_over_time(name="jp@gc - Response Times Over Time", params={}, &block)
        node = Gridinit::Jmeter::GCResponseTimesOverTime.new(name, params)
        attach_node(node, &block)
      end

      def response_times_percentiles(name="jp@gc - Response Times Percentiles", params={}, &block)
        node = Gridinit::Jmeter::GCResponseTimesPercentiles.new(name, params)
        attach_node(node, &block)
      end

      def transactions_per_second(name="jp@gc - Transactions per Second", params={}, &block)
        node = Gridinit::Jmeter::GCTransactionsPerSecond.new(name, params)
        attach_node(node, &block)
      end

      def latencies_over_time(name="jp@gc - Response Latencies Over Time", params={}, &block)
        node = Gridinit::Jmeter::GCLatenciesOverTime.new(name, params)
        attach_node(node, &block)
      end

      def console_status_logger(name="jp@gc - Console Status Logger", params={}, &block)
        node = Gridinit::Jmeter::GCConsoleStatusLogger.new(name, params)
        attach_node(node, &block)
      end

      alias_method :console, :console_status_logger

      def throughput_shaper(name="jp@gc - Throughput Shaping Timer", steps=[], params={}, &block)
        node = Gridinit::Jmeter::GCThroughputShapingTimer.new(name, steps)
        attach_node(node, &block)
      end

      alias_method :shaper, :throughput_shaper

      def dummy_sampler(name="jp@gc - Dummy Sampler", params={}, &block)
        node = Gridinit::Jmeter::GCDummySampler.new(name, params)
        attach_node(node, &block)
      end

      alias_method :dummy, :dummy_sampler

      # API Methods

      def out(params={})
        puts doc.to_xml(:indent => 2)
      end

      def jmx(params={})
        file(params)
        logger.info "Test plan saved to: #{params[:file]}"
      end

      def to_xml
        doc.to_xml(:indent => 2)
      end

      def to_doc
        doc.clone
      end

      def run(params={})
        file(params)
        logger.warn "Test executing locally ..."
        cmd = "#{params[:path]}jmeter #{"-n" unless params[:gui] } -t #{params[:file]} -j #{params[:log] ? params[:log] : 'jmeter.log' } -l #{params[:jtl] ? params[:jtl] : 'jmeter.jtl' }"
        logger.debug cmd if params[:debug]
        Open3.popen2e("#{cmd} -q #{File.dirname(__FILE__)}/helpers/jmeter.properties") do |stdin, stdout_err, wait_thr|
          while line = stdout_err.gets
            logger.debug line.chomp if params[:debug]
          end

          exit_status = wait_thr.value
          unless exit_status.success?
            abort "FAILED !!! #{cmd}"
          end
        end
        logger.info "Local Results at: #{params[:jtl] ? params[:jtl] : 'jmeter.jtl'}"
      end

      def grid(token, params={})
        if params[:region] == 'local'
          logger.info "Starting test ..."
          params[:started] = Time.now
          run params
          params[:completed] = Time.now
          logger.info "Completed test ..."
          logger.debug "Uploading results ..." if params[:debug]
        end
        RestClient.proxy = params[:proxy] if params[:proxy]
        begin
          file = Tempfile.new(['jmeter', '.jmx'])
          file.write(doc.to_xml(:indent => 2))
          file.rewind
          response = RestClient.post "http://#{params[:endpoint] ? params[:endpoint] : 'gridinit.com'}/api?token=#{token}&region=#{params[:region]}",
          {
            :name => 'attachment',
            :attachment => File.new("#{file.path}", 'rb'),
            :results => (File.new("#{params[:jtl] ? params[:jtl] : 'jmeter.jtl'}", 'rb') if params[:region] == 'local'),
            :multipart => true,
            :content_type => 'application/octet-stream',
            :started => params[:started],
            :completed => params[:completed]
          }
          logger.info "Grid Results at: #{JSON.parse(response)["results"]}" if response.code == 200
        rescue => e
          logger.fatal "There was an error: #{e.message}"
        end
      end

      private

      def hash_tree
        Nokogiri::XML::Node.new("hashTree", @root)
      end

      def attach_to_last(node)
        ht        = hash_tree
        last_node = @current_node
        last_node << node.doc.children << ht
        ht
      end

      def attach_node(node, &block)
        ht            = attach_to_last(node)
        previous      = @current_node
        @current_node = ht
        self.instance_exec(&block) if block
        @current_node = previous
      end

      def file(params={})
        params[:file] ||= 'jmeter.jmx'
        File.open(params[:file], 'w') { |file| file.write(doc.to_xml(:indent => 2)) }
      end

      def doc
        Nokogiri::XML(@root.to_s, &:noblanks)
      end

      def logger
        @log       ||= Logger.new(STDOUT)
        @log.level = Logger::DEBUG
        @log
      end

    end

  end
end

def test(params = {}, &block)
  Gridinit.dsl_eval(Gridinit::Jmeter::ExtendedDSL.new(params), &block)
end
